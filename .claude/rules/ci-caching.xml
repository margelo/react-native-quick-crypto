<rules category="ci-caching">
  <metadata>
    <trigger>when working on GitHub Actions workflows or CI caching</trigger>
  </metadata>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Reference Implementations</name>
    <description>Use these repos as reference for CI patterns</description>
    <references>
      <reference>
        <path>$REPOS/nitro</path>
        <description>Super-fast iOS builds with proper caching</description>
        <files>.github/workflows/build-ios.yml</files>
      </reference>
      <reference>
        <path>$REPOS/spicy</path>
        <description>Working Android E2E with Maestro</description>
        <files>.github/workflows/e2e.yml, tests/e2e/scripts/</files>
      </reference>
    </references>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>iOS Pods and DerivedData Cache Consistency</name>
    <description>Pods project files contain hardcoded paths to DerivedData</description>
    <problem>
      Pods cache contains xcodeproj files that reference paths like ios/build/generated/ios/*.cpp.
      If Pods restores but DerivedData doesn't, build fails with "Build input file cannot be found".
    </problem>
    <solutions>
      <solution>Use exact-match only for Pods cache (no restore-keys fallback)</solution>
      <solution>Ensure DerivedData cache key is superset of Pods cache key</solution>
      <solution>Restore DerivedData AFTER pod install runs (like Nitro does)</solution>
    </solutions>
    <antipattern>
      Using restore-keys for Pods cache can restore stale Pods that reference non-existent codegen files.
    </antipattern>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>Cache Key Design — Content-Addressed Keys</name>
    <description>Use hashFiles() for cache keys so identical inputs produce cache hits</description>
    <problem>
      GitHub Actions caches are immutable — once saved, a key cannot be overwritten.
      Using github.run_id makes keys unique per run, so the primary key NEVER hits on
      restore. Every build falls through to restore-keys and gets a stale cache that
      xcodebuild/Gradle must then re-validate, which can be slower than a clean build.
    </problem>
    <guidelines>
      <guideline>Use hashFiles() of lock files for cache keys (Podfile.lock, Gemfile.lock, bun.lock)</guideline>
      <guideline>Include Xcode version in DerivedData key suffix (e.g. -xcode26.2)</guideline>
      <guideline>Use actions/cache@v5 (unified) instead of separate cache/restore + cache/save</guideline>
      <guideline>Use restore-keys for DerivedData (partial hits useful), NOT for Pods (stale Pods break builds)</guideline>
      <guideline>Don't use version suffixes (v2, v3) — purge with gh cache delete --all</guideline>
      <guideline>Old cache entries are evicted automatically by GitHub's LRU policy</guideline>
    </guidelines>
    <example>
      Pods: key=runner.os-pods-${{ hashFiles('example/ios/Podfile.lock', 'example/Gemfile.lock') }}
      DD:   key=runner.os-dd-${{ hashFiles('...lockfiles...') }}-xcode26.2, restore-keys=runner.os-dd-
    </example>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Android Maestro App Launch</name>
    <description>Don't launch app before Maestro</description>
    <problem>
      If you launch the app via adb before Maestro runs, Maestro's launchApp command
      will restart it, potentially breaking Metro connection.
    </problem>
    <solution>
      Let Maestro handle app launch. Only install the APK before Maestro runs.
    </solution>
  </rule>

  <rule severity="MEDIUM" enforcement="GUIDANCE">
    <name>Debugging CI Failures</name>
    <description>Commands for investigating CI issues</description>
    <commands>
      <command>gh run list --branch BRANCH --limit 5</command>
      <command>gh run view RUN_ID --log-failed</command>
      <command>gh run download RUN_ID --name ARTIFACT -D /tmp/output</command>
      <command>gh cache list</command>
      <command>gh cache delete --all</command>
    </commands>
  </rule>

  <rule severity="MEDIUM" enforcement="GUIDANCE">
    <name>Build Speed Targets</name>
    <description>Expected build times with proper caching</description>
    <targets>
      <target>iOS incremental build: under 2 minutes</target>
      <target>Android incremental build: under 3 minutes</target>
      <target>Full iOS build (no cache): ~15-20 minutes</target>
      <target>Full Android build (no cache): ~10 minutes</target>
    </targets>
    <notes>
      ccache handles C++ compilation caching.
      DerivedData/Gradle caches handle build artifacts.
    </notes>
  </rule>
</rules>
