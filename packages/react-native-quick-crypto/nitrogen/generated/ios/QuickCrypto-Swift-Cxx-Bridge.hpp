///
/// QuickCrypto-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `ArrayBufferHolder` to properly resolve imports.
namespace NitroModules { class ArrayBufferHolder; }
// Forward declaration of `ArrayBuffer` to properly resolve imports.
namespace NitroModules { class ArrayBuffer; }
// Forward declaration of `JWKkty` to properly resolve imports.
namespace margelo::nitro::crypto { enum class JWKkty; }
// Forward declaration of `JWKuse` to properly resolve imports.
namespace margelo::nitro::crypto { enum class JWKuse; }
// Forward declaration of `KFormatType` to properly resolve imports.
namespace margelo::nitro::crypto { enum class KFormatType; }
// Forward declaration of `KeyEncoding` to properly resolve imports.
namespace margelo::nitro::crypto { enum class KeyEncoding; }
// Forward declaration of `KeyType` to properly resolve imports.
namespace margelo::nitro::crypto { enum class KeyType; }
// Forward declaration of `KeyUsage` to properly resolve imports.
namespace margelo::nitro::crypto { enum class KeyUsage; }
// Forward declaration of `NamedCurve` to properly resolve imports.
namespace margelo::nitro::crypto { enum class NamedCurve; }

// Include C++ defined types
#if __has_include("JWKkty.hpp")
 #include "JWKkty.hpp"
#endif
#if __has_include("JWKuse.hpp")
 #include "JWKuse.hpp"
#endif
#if __has_include("KFormatType.hpp")
 #include "KFormatType.hpp"
#endif
#if __has_include("KeyEncoding.hpp")
 #include "KeyEncoding.hpp"
#endif
#if __has_include("KeyType.hpp")
 #include "KeyType.hpp"
#endif
#if __has_include("KeyUsage.hpp")
 #include "KeyUsage.hpp"
#endif
#if __has_include("NamedCurve.hpp")
 #include "NamedCurve.hpp"
#endif
#if __has_include(<NitroModules/ArrayBuffer.hpp>)
 #include <NitroModules/ArrayBuffer.hpp>
#endif
#if __has_include(<NitroModules/ArrayBufferHolder.hpp>)
 #include <NitroModules/ArrayBufferHolder.hpp>
#endif
#if __has_include(<NitroModules/PromiseHolder.hpp>)
 #include <NitroModules/PromiseHolder.hpp>
#endif
#if __has_include(<functional>)
 #include <functional>
#endif
#if __has_include(<future>)
 #include <future>
#endif
#if __has_include(<memory>)
 #include <memory>
#endif
#if __has_include(<optional>)
 #include <optional>
#endif
#if __has_include(<string>)
 #include <string>
#endif
#if __has_include(<variant>)
 #include <variant>
#endif
#if __has_include(<vector>)
 #include <vector>
#endif

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::crypto::bridge::swift {

  /**
   * Specialized version of `std::optional<KFormatType>`.
   */
  using std__optional_KFormatType_ = std::optional<KFormatType>;
  inline std::optional<KFormatType> create_std__optional_KFormatType_(const KFormatType& value) {
    return std::optional<KFormatType>(value);
  }
  
  /**
   * Specialized version of `std::optional<KeyEncoding>`.
   */
  using std__optional_KeyEncoding_ = std::optional<KeyEncoding>;
  inline std::optional<KeyEncoding> create_std__optional_KeyEncoding_(const KeyEncoding& value) {
    return std::optional<KeyEncoding>(value);
  }
  
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) {
    return std::optional<std::string>(value);
  }
  
  /**
   * Specialized version of `std::optional<std::shared_ptr<ArrayBuffer>>`.
   */
  using std__optional_std__shared_ptr_ArrayBuffer__ = std::optional<std::shared_ptr<ArrayBuffer>>;
  inline std::optional<std::shared_ptr<ArrayBuffer>> create_std__optional_std__shared_ptr_ArrayBuffer__(const std::shared_ptr<ArrayBuffer>& value) {
    return std::optional<std::shared_ptr<ArrayBuffer>>(value);
  }
  
  /**
   * Specialized version of `std::optional<JWKkty>`.
   */
  using std__optional_JWKkty_ = std::optional<JWKkty>;
  inline std::optional<JWKkty> create_std__optional_JWKkty_(const JWKkty& value) {
    return std::optional<JWKkty>(value);
  }
  
  /**
   * Specialized version of `std::optional<JWKuse>`.
   */
  using std__optional_JWKuse_ = std::optional<JWKuse>;
  inline std::optional<JWKuse> create_std__optional_JWKuse_(const JWKuse& value) {
    return std::optional<JWKuse>(value);
  }
  
  /**
   * Specialized version of `std::vector<KeyUsage>`.
   */
  using std__vector_KeyUsage_ = std::vector<KeyUsage>;
  inline std::vector<KeyUsage> create_std__vector_KeyUsage_(size_t size) {
    std::vector<KeyUsage> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::optional<std::vector<KeyUsage>>`.
   */
  using std__optional_std__vector_KeyUsage__ = std::optional<std::vector<KeyUsage>>;
  inline std::optional<std::vector<KeyUsage>> create_std__optional_std__vector_KeyUsage__(const std::vector<KeyUsage>& value) {
    return std::optional<std::vector<KeyUsage>>(value);
  }
  
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) {
    return std::optional<std::vector<std::string>>(value);
  }
  
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) {
    return std::optional<bool>(value);
  }
  
  /**
   * Specialized version of `std::variant<std::string, std::shared_ptr<ArrayBuffer>>`.
   */
  using std__variant_std__string__std__shared_ptr_ArrayBuffer__ = std::variant<std::string, std::shared_ptr<ArrayBuffer>>;
  inline std::variant<std::string, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__std__shared_ptr_ArrayBuffer__(const std::string& value) {
    return value;
  }
  inline std::variant<std::string, std::shared_ptr<ArrayBuffer>> create_std__variant_std__string__std__shared_ptr_ArrayBuffer__(const std::shared_ptr<ArrayBuffer>& value) {
    return value;
  }
  inline std::string get_std__variant_std__string__std__shared_ptr_ArrayBuffer___0(const std::variant<std::string, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<0>(variant);
  }
  inline std::shared_ptr<ArrayBuffer> get_std__variant_std__string__std__shared_ptr_ArrayBuffer___1(const std::variant<std::string, std::shared_ptr<ArrayBuffer>>& variant) {
    return std::get<1>(variant);
  }
  
  /**
   * Specialized version of `std::optional<KeyType>`.
   */
  using std__optional_KeyType_ = std::optional<KeyType>;
  inline std::optional<KeyType> create_std__optional_KeyType_(const KeyType& value) {
    return std::optional<KeyType>(value);
  }
  
  /**
   * Specialized version of `std::optional<NamedCurve>`.
   */
  using std__optional_NamedCurve_ = std::optional<NamedCurve>;
  inline std::optional<NamedCurve> create_std__optional_NamedCurve_(const NamedCurve& value) {
    return std::optional<NamedCurve>(value);
  }
  
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) {
    return std::optional<double>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::shared_ptr<ArrayBuffer>>`.
   */
  using PromiseHolder_std__shared_ptr_ArrayBuffer__ = PromiseHolder<std::shared_ptr<ArrayBuffer>>;
  inline PromiseHolder<std::shared_ptr<ArrayBuffer>> create_PromiseHolder_std__shared_ptr_ArrayBuffer__() {
    return PromiseHolder<std::shared_ptr<ArrayBuffer>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::future<std::shared_ptr<ArrayBuffer>>>(const std::shared_ptr<ArrayBuffer>&, const std::shared_ptr<ArrayBuffer>&, double, double, const std::string&)>`.
   */
  using Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string = std::function<std::future<std::future<std::shared_ptr<ArrayBuffer>>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)>;
  /**
   * Wrapper class for a `std::function<std::future<std::future<std::shared_ptr<ArrayBuffer>>>(const std::shared_ptr<ArrayBuffer>& / * password * /, const std::shared_ptr<ArrayBuffer>& / * salt * /, double / * iterations * /, double / * keylen * /, const std::string& / * digest * /)>`, this can be used from Swift.
   */
  class Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper {
  public:
    explicit Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper(const std::function<std::future<std::future<std::shared_ptr<ArrayBuffer>>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)>& func): function(func) {}
    explicit Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper(std::function<std::future<std::future<std::shared_ptr<ArrayBuffer>>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)>&& func): function(std::move(func)) {}
  
    PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>> call(ArrayBufferHolder password, ArrayBufferHolder salt, double iterations, double keylen, std::string digest) const {
      auto result = function(password.getArrayBuffer(), salt.getArrayBuffer(), iterations, keylen, digest);
      return []() -> PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>> { throw std::runtime_error("Promise<..> cannot be converted to Swift yet!"); }();
    }
  
    std::function<std::future<std::future<std::shared_ptr<ArrayBuffer>>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)> function;
  };
  inline Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string create_Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string(void* closureHolder, PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>>(*call)(void* /* closureHolder */, ArrayBufferHolder, ArrayBufferHolder, double, double, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string([sharedClosureHolder, call](const std::shared_ptr<ArrayBuffer>& password, const std::shared_ptr<ArrayBuffer>& salt, double iterations, double keylen, const std::string& digest) -> std::future<std::future<std::shared_ptr<ArrayBuffer>>> {
      auto result = call(sharedClosureHolder.get(), ArrayBufferHolder(password), ArrayBufferHolder(salt), iterations, keylen, digest);
      return result.getFuture();
    });
  }
  inline std::shared_ptr<Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper> share_Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string(const Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string& value) {
    return std::make_shared<Func_std__future_std__future_std__shared_ptr_ArrayBuffer____std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper>(value);
  }
  
  /**
   * Specialized version of `PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>>`.
   */
  using PromiseHolder_std__future_std__shared_ptr_ArrayBuffer___ = PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>>;
  inline PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>> create_PromiseHolder_std__future_std__shared_ptr_ArrayBuffer___() {
    return PromiseHolder<std::future<std::shared_ptr<ArrayBuffer>>>();
  }
  
  /**
   * Specialized version of `std::function<std::future<std::shared_ptr<ArrayBuffer>>(const std::shared_ptr<ArrayBuffer>&, const std::shared_ptr<ArrayBuffer>&, double, double, const std::string&)>`.
   */
  using Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string = std::function<std::future<std::shared_ptr<ArrayBuffer>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)>;
  /**
   * Wrapper class for a `std::function<std::future<std::shared_ptr<ArrayBuffer>>(const std::shared_ptr<ArrayBuffer>& / * password * /, const std::shared_ptr<ArrayBuffer>& / * salt * /, double / * iterations * /, double / * keylen * /, const std::string& / * digest * /)>`, this can be used from Swift.
   */
  class Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper {
  public:
    explicit Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper(const std::function<std::future<std::shared_ptr<ArrayBuffer>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)>& func): function(func) {}
    explicit Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper(std::function<std::future<std::shared_ptr<ArrayBuffer>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)>&& func): function(std::move(func)) {}
  
    PromiseHolder<std::shared_ptr<ArrayBuffer>> call(ArrayBufferHolder password, ArrayBufferHolder salt, double iterations, double keylen, std::string digest) const {
      auto result = function(password.getArrayBuffer(), salt.getArrayBuffer(), iterations, keylen, digest);
      return []() -> PromiseHolder<std::shared_ptr<ArrayBuffer>> { throw std::runtime_error("Promise<..> cannot be converted to Swift yet!"); }();
    }
  
    std::function<std::future<std::shared_ptr<ArrayBuffer>>(const std::shared_ptr<ArrayBuffer>& /* password */, const std::shared_ptr<ArrayBuffer>& /* salt */, double /* iterations */, double /* keylen */, const std::string& /* digest */)> function;
  };
  inline Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string create_Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string(void* closureHolder, PromiseHolder<std::shared_ptr<ArrayBuffer>>(*call)(void* /* closureHolder */, ArrayBufferHolder, ArrayBufferHolder, double, double, std::string), void(*destroy)(void*)) {
    std::shared_ptr<void> sharedClosureHolder(closureHolder, destroy);
    return Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string([sharedClosureHolder, call](const std::shared_ptr<ArrayBuffer>& password, const std::shared_ptr<ArrayBuffer>& salt, double iterations, double keylen, const std::string& digest) -> std::future<std::shared_ptr<ArrayBuffer>> {
      auto result = call(sharedClosureHolder.get(), ArrayBufferHolder(password), ArrayBufferHolder(salt), iterations, keylen, digest);
      return result.getFuture();
    });
  }
  inline std::shared_ptr<Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper> share_Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string(const Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string& value) {
    return std::make_shared<Func_std__future_std__shared_ptr_ArrayBuffer___std__shared_ptr_ArrayBuffer__std__shared_ptr_ArrayBuffer__double_double_std__string_Wrapper>(value);
  }

} // namespace margelo::nitro::crypto::bridge::swift
